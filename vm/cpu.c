/*
 * cpu.c
 * our virtual 8bit cpu (heavily inspired by 6502)
 */
#include <stdlib.h>
#include <memory.h>
#include "cpu.h"
#include <stdio.h>


/*
 * makro to convert 2 uint8 to one uint16
 */
/*#define mkword(lo, hi) \
	((uint16_t)((uint8_t)(lo)) | (((uint16_t)(uint8_t)(hi))<<8))
*/
static inline uint16_t mkword(uint8_t lo, uint8_t hi)
{
	return ((uint16_t)((uint8_t)(lo)) | (((uint16_t)(uint8_t)(hi))<<8));
}


cpu_t *cpu_new(void)
{
	cpu_t *c = malloc(sizeof(struct cpu_s));
	memset(c, 0x00, sizeof(struct cpu_s));
	c->mem = malloc(sizeof(uint8_t) * 0xffff);	//64kb
	memset(c->mem, 0x00, sizeof(uint8_t) * 0xffff);
	c->x = c->y = c->acc = 0;
	c->pc = 0;
	c->sp = 0x01ff;
	c->status = 0x00;
	c->unnamed = 1;
	return c;
}

void cpu_free(cpu_t *cpu)
{
	free(cpu->mem);
	free(cpu);
}

void cpu_exec(cpu_t *cpu, uint16_t base, void *opcds, size_t len)
{
	void **octbl[] = {
		0x00,	0x00,	0x00,		0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,		0x00,	0x00,	0x00,		0x00,		0x00,	0x00,		// 00h
		0x00,	0x00,	0x00,		0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,		0x00,	0x00,	0x00,		0x00,		0x00,	0x00,		// 10h
		0x00,	0x00,	0x00,		0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,		0x00,	0x00,	0x00,		0x00,		0x00,	0x00,		// 20h
		0x00,	0x00,	0x00,		0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,		0x00,	0x00,	0x00,		0x00,		0x00,	0x00,		// 30h
		0x00,	0x00,	0x00,		0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,		0x00,	0x00,	&& jmpabs,	0x00,		0x00,	0x00,		// 40h
		0x00,	0x00,	0x00,		0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,		0x00,	0x00,	0x00,		0x00,		0x00,	0x00,		// 50h
		0x00,	0x00,	0x00,		0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	&& adcimm,	0x00,	0x00,	0x00,		0x00,		0x00,	0x00,		// 60h
		0x00,	0x00,	0x00,		0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,		0x00,	0x00,	0x00,		0x00,		0x00,	0x00,		// 70h
		0x00,	0x00,	0x00,		0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,		0x00,	0x00,	0x00,		0x00,		0x00,	0x00,		// 80h
		0x00,	0x00,	0x00,		0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,		0x00,	0x00,	0x00,		&& staabx,	0x00,	0x00,		// 90h
		0x00,	0x00,	&& ldximm,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	&& ldaimm,	0x00,	0x00,	0x00,		0x00,		0x00,	0x00,		// A0h
		0x00,	0x00,	0x00,		0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,		0x00,	0x00,	0x00,		&& ldaabx,	0x00,	0x00,		// B0h
		0x00,	0x00,	0x00,		0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,		0x00,	0x00,	0x00,		0x00,		0x00,	0x00,		// C0h
		0x00,	0x00,	0x00,		0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,		0x00,	0x00,	0x00,		0x00,		0x00,	0x00,		// D0h
		0x00,	0x00,	0x00,		0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,		0x00,	0x00,	0x00,		0x00,		0x00,	0x00,		// E0h
		0x00,	0x00,	0x00,		0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,		0x00,	0x00,	0x00,		0x00,		0x00,	&& dmpcpu // F0h
	};

	memcpy((cpu->mem + base), opcds, len);


	uint8_t oc;
	cpu->pc = base;
loop:
	if (cpu->pc >= len + base) {
		goto end;
	}
	oc = cpu->mem[cpu->pc];
	cpu->pc++;

	//skip invalid opcodes
	if (octbl[oc] == 0x00) {
		goto loop;
	}

	goto *octbl[oc];

jmpabs: //jmp absolute to $(op1op2)
	cpu->pc = mkword(cpu->mem[cpu->pc], cpu->mem[cpu->pc + 1]);
	goto loop;

ldaimm: //load op1 into acc
	cpu->acc = cpu->mem[cpu->pc];
	cpu->zero_flag = (cpu->acc == 0);
	cpu->pc += 1;
	goto loop;

ldximm: //load op1 into x
	cpu->x = cpu->mem[cpu->pc];
	cpu->zero_flag = (cpu->x == 0);
	cpu->pc += 1;
	goto loop;

staabx: //store acc into $(op1op2) + x
	cpu->mem[
	    mkword(cpu->mem[cpu->pc], cpu->mem[cpu->pc + 1])
	    + cpu->x] = cpu->acc;
	cpu->pc += 2;
	goto loop;

ldaabx: //load acc from $(op1op2) + x
	cpu->acc = cpu->mem[
	               mkword(cpu->mem[cpu->pc], cpu->mem[cpu->pc + 1])
	               + cpu->x];
	cpu->pc += 2;
	goto loop;

adcimm: //add op1 to acc
	cpu->acc += cpu->mem[cpu->pc] + cpu->carry_flag;

	cpu->zero_flag = (cpu->acc == 0);
	cpu->carry_flag = (cpu->acc == 0);
	cpu->negative_flag = (cpu->acc & 0x80) >> 7;
	cpu->pc += 1;
	goto loop;

dmpcpu: //dump cpu info
	printf("opcode 0xff dmpcpu:");
	printf("\n===========================================\n");
	printf("\tip:\t%.4x\n", cpu->pc);
	printf("\tsp:\t%.2x\n", cpu->sp);
	printf("\tstatus:\t%.2x\n", cpu->status);
	printf("\t\t|nf|of|??|bc|dm|id|zf|cf|\n");
	printf("\t\t| %i| %i| %i| %i| %i| %i| %i| %i|\n",
			cpu->negative_flag,
			cpu->overflow_flag,
			cpu->unnamed,
			cpu->break_command,
			cpu->decimal_mode,
			cpu->interrupt_disable,
			cpu->zero_flag,
			cpu->carry_flag);
	printf("\n");
	printf("\tacc:\t%.2x\n", cpu->acc);
	printf("\tx:\t%.2x\n", cpu->x);
	printf("\ty:\t%.2x\n", cpu->y);
	printf("===========================================\n");
	goto loop;

end:
	return;
}

